// DariX Performance Benchmark Suite
// Ù…Ø¬Ù…ÙˆØ¹Ù‡ ØªØ³Øªâ€ŒÙ‡Ø§ÛŒ Ø¹Ù…Ù„Ú©Ø±Ø¯ DariX

print("ðŸš€ DariX Performance Benchmark Suite")
print("====================================")

// Timing utility function - simplified version
func benchmark(name, iterations, test_func) {
    print("\nðŸ“Š Benchmarking:", name)
    print("Iterations:", iterations)
    
    // Simple iteration count for performance comparison
    for (var i = 0; i < iterations; i = i + 1) {
        test_func()
    }
    
    print("âœ… Completed", iterations, "iterations")
    print("---")
}

// Benchmark 1: Basic arithmetic operations
func arithmetic_test() {
    var a = 42
    var b = 17
    var result = a + b * 2 - 5 / 2 + a % b
}

// Benchmark 2: String operations
func string_test() {
    var s1 = "Hello"
    var s2 = "World"
    var s3 = s1 + " " + s2 + "!"
    var length = len(s3)
}

// Benchmark 3: Array operations
func array_test() {
    var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    var sum_val = sum(arr)
    var length = len(arr)
    var first = arr[0]
    var last = arr[length - 1]
}

// Benchmark 4: Map operations
func map_test() {
    var map_obj = {"a": 1, "b": 2, "c": 3, "d": 4, "e": 5}
    var val_a = map_obj["a"]
    var val_c = map_obj["c"]
    map_obj["f"] = 6
    var length = len(map_obj)
}

// Benchmark 5: Function calls
func simple_func(x, y) {
    return x * y + 1
}

func function_call_test() {
    var result = simple_func(5, 7)
    result = simple_func(result, 2)
}

// Benchmark 6: Recursive function (Fibonacci)
func fibonacci(n) {
    if (n <= 1) {
        return n
    }
    return fibonacci(n - 1) + fibonacci(n - 2)
}

func fibonacci_test() {
    var result = fibonacci(15)  // Small number to avoid timeout
}

// Benchmark 7: Loop performance
func loop_test() {
    var sum_val = 0
    for (var i = 0; i < 1000; i = i + 1) {
        sum_val = sum_val + i
    }
}

// Benchmark 8: Object creation and method calls
class TestClass {
    func __init__(self, value) {
        self.value = value
    }
    
    func multiply(self, factor) {
        return self.value * factor
    }
    
    func add(self, other) {
        self.value = self.value + other
        return self.value
    }
}

func object_test() {
    var obj = TestClass(42)
    var result = obj.multiply(2)
    obj.add(10)
}

// Benchmark 9: Built-in function performance
func builtin_test() {
    var arr = [5, 2, 8, 1, 9, 3]
    var sorted_arr = sort(arr)
    var reversed_arr = reverse(arr)
    var abs_val = abs(-42)
    var str_val = str(123)
    var int_val = int("456")
}

// Benchmark 10: Complex nested operations
func complex_test() {
    var data = {
        "users": [
            {"name": "Ali", "age": 25, "scores": [85, 92, 78]},
            {"name": "Sara", "age": 30, "scores": [90, 88, 95]},
            {"name": "Reza", "age": 28, "scores": [75, 82, 89]}
        ]
    }
    
    var total_score = 0
    var user_count = len(data["users"])
    
    for (var i = 0; i < user_count; i = i + 1) {
        var user = data["users"][i]
        var scores = user["scores"]
        var user_total = sum(scores)
        total_score = total_score + user_total
    }
    
    var average = total_score / (user_count * 3)
}

// Run all benchmarks
print("Starting performance benchmarks...")
print("Each test will run multiple iterations for accurate timing.")

// Light benchmarks (reduced iterations for testing)
benchmark("Arithmetic Operations", 10000, arithmetic_test)
benchmark("String Operations", 5000, string_test)
benchmark("Array Operations", 2500, array_test)
benchmark("Map Operations", 2500, map_test)
benchmark("Function Calls", 5000, function_call_test)

// Medium benchmarks
benchmark("Loop Performance", 100, loop_test)
benchmark("Object Operations", 1000, object_test)
benchmark("Built-in Functions", 1000, builtin_test)

// Heavy benchmarks (fewer iterations)
benchmark("Fibonacci Recursive", 10, fibonacci_test)
benchmark("Complex Nested Operations", 100, complex_test)

print("\nðŸŽ¯ Benchmark Summary:")
print("=====================")
print("âœ… All benchmarks completed successfully!")
print("ðŸ“ˆ Use these results to identify performance bottlenecks")
print("ðŸ”§ Focus optimization efforts on slowest operations")
print("\nNote: Results may vary based on system performance and current load.")
